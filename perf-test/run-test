#!/usr/bin/env bash
#
# Run a single PicoShare performance test with Firecracker
#
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source network configuration
source "$SCRIPT_DIR/fc-network-config"

# Defaults
RAM_MB="${1:-2048}"
FILE_SIZE="${2:-100M}"
TIMEOUT_SECONDS=600
PORT=4001
PS_SHARED_SECRET="perftestpassword"
RESULTS_DIR="$SCRIPT_DIR/results"
NUM_ITERATIONS="${NUM_ITERATIONS:-10}"  # Number of upload repetitions

# Firecracker paths
FC_KERNEL="$SCRIPT_DIR/firecracker-images/vmlinux.bin"
FC_ROOTFS="$SCRIPT_DIR/firecracker-images/rootfs-working.ext4"
FC_SOCKET="/tmp/firecracker-$$.sock"
TAP_DEV="fc-tap-$$"

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

die() {
    log "ERROR: $*"
    exit 1
}

PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Build PicoShare binary using dev-scripts/build-backend
build_binary() {
    log "==================================================="
    log "Building PicoShare binary..."
    log "==================================================="

    cd "$PROJECT_ROOT"

    # Set version for build script
    export PS_VERSION="${PS_VERSION:-dev}"

    "$PROJECT_ROOT/dev-scripts/build-backend"

    if [[ ! -f "$PROJECT_ROOT/bin/picoshare" ]]; then
        log "ERROR: Build failed - picoshare binary not found"
        exit 1
    fi

    log "✓ Build complete: $(ls -lh "$PROJECT_ROOT/bin/picoshare" | awk '{print $5}')"
    log ""
}

# Update VM image with new binary
update_vm_image() {
    log "==================================================="
    log "Updating VM image with new binary..."
    log "==================================================="

    local rootfs="$SCRIPT_DIR/firecracker-images/rootfs-working.ext4"
    local mount_point="/mnt"

    if [[ ! -f "$rootfs" ]]; then
        log "ERROR: VM rootfs not found at $rootfs"
        exit 1
    fi

    log "Mounting $rootfs..."
    sudo mount -o loop "$rootfs" "$mount_point"

    log "Copying binary to /usr/local/bin/picoshare..."
    sudo cp "$PROJECT_ROOT/bin/picoshare" "$mount_point/usr/local/bin/picoshare"

    log "Cleaning /tmp to free disk space..."
    sudo rm -rf "$mount_point"/tmp/* 2>/dev/null || true

    log "Unmounting..."
    sudo umount "$mount_point"

    log "✓ VM image updated and cleaned"
    log ""
}

cleanup() {
    local exit_code=$?
    log "Cleaning up..."

    # Stop Firecracker
    if [[ -S "$FC_SOCKET" ]]; then
        curl -s -X PUT --unix-socket "$FC_SOCKET" \
            http://localhost/actions \
            -H "Content-Type: application/json" \
            -d '{"action_type": "SendCtrlAltDel"}' 2>/dev/null || true
        sleep 1
        rm -f "$FC_SOCKET"
    fi

    # Remove TAP device and route
    sudo ip route del "$FC_NETWORK" dev "$TAP_DEV" 2>/dev/null || true
    sudo ip link del "$TAP_DEV" 2>/dev/null || true

    # Kill any background processes
    jobs -p | xargs -r kill 2>/dev/null || true

    exit $exit_code
}

trap cleanup EXIT INT TERM

# Validate inputs
[[ ! -f "$FC_KERNEL" ]] && die "Kernel not found: $FC_KERNEL"
[[ ! -f "$FC_ROOTFS" ]] && die "Rootfs not found: $FC_ROOTFS"
TEST_FILE="$SCRIPT_DIR/test-files/${FILE_SIZE}.bin"
[[ ! -f "$TEST_FILE" ]] && die "Test file not found: $TEST_FILE"

# Build and update VM before running test
build_binary
update_vm_image

mkdir -p "$RESULTS_DIR"
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
RESULT_FILE="$RESULTS_DIR/result-fc-${RAM_MB}MB-${FILE_SIZE}-${TIMESTAMP}.json"

log "=== PicoShare Firecracker Performance Test ==="
log "RAM: ${RAM_MB}MB"
log "File: $FILE_SIZE"
log "Iterations: $NUM_ITERATIONS"
log ""

# Create TAP device
log "Setting up network..."
sudo ip tuntap add "$TAP_DEV" mode tap
sudo ip addr add "${FC_TAP_IP}/${FC_GUEST_MASK}" dev "$TAP_DEV"
sudo ip link set "$TAP_DEV" up

# Enable IP forwarding
sudo sysctl -w net.ipv4.ip_forward=1 >/dev/null

# Set up NAT (so guest can reach internet if needed)
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE 2>/dev/null || true
sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
sudo iptables -A FORWARD -i "$TAP_DEV" -o eth0 -j ACCEPT 2>/dev/null || true

# Create Firecracker config
log "Creating VM config..."
cat > /tmp/fc-config-$$.json << EOF
{
  "boot-source": {
    "kernel_image_path": "$FC_KERNEL",
    "boot_args": "console=ttyS0 reboot=k panic=1 pci=off ip=${FC_GUEST_IP}::${FC_TAP_IP}:255.255.255.0::eth0:off init=/sbin/init-picoshare random.trust_cpu=on"
  },
  "drives": [
    {
      "drive_id": "rootfs",
      "path_on_host": "$FC_ROOTFS",
      "is_root_device": true,
      "is_read_only": false
    }
  ],
  "machine-config": {
    "vcpu_count": 1,
    "mem_size_mib": ${RAM_MB}
  },
  "network-interfaces": [
    {
      "iface_id": "eth0",
      "guest_mac": "AA:FC:00:00:00:01",
      "host_dev_name": "$TAP_DEV"
    }
  ],
  "entropy": null
}
EOF

# Start Firecracker
log "Starting Firecracker VM..."
start_time=$(date +%s.%N)

rm -f "$FC_SOCKET"
/usr/local/bin/firecracker --api-sock "$FC_SOCKET" --config-file /tmp/fc-config-$$.json > /tmp/fc-console-$$.log 2>&1 &
FC_PID=$!

# Wait for API socket
attempts=0
while [[ ! -S "$FC_SOCKET" ]] && [[ $attempts -lt 50 ]]; do
    sleep 0.1
    attempts=$((attempts + 1))
done

[[ ! -S "$FC_SOCKET" ]] && die "Firecracker API socket not created"

boot_end=$(date +%s.%N)
boot_time=$(awk "BEGIN {printf \"%.2f\", $boot_end - $start_time}")
log "VM booted in ${boot_time}s"

# Wait for network to be ready
log "Waiting for guest to boot..."
sleep 10
log "Guest should be ready (boot time ~0.1s + init ~10s)"

# Wait for PicoShare to start
log "Waiting for PicoShare..."
log "Network state:"
ip addr show "$TAP_DEV" || log "TAP device not found!"
ip route | grep "${FC_NETWORK%/*}" || log "No route to guest!"

attempts=0
while [[ $attempts -lt 60 ]]; do
    if curl -sf -m 10 "http://${FC_GUEST_IP}:4001/" > /dev/null 2>&1; then
        log "PicoShare is ready"
        break
    fi
    sleep 1
    attempts=$((attempts + 1))
done

[[ $attempts -eq 60 ]] && die "PicoShare not ready after 60s"

# Authenticate
log "Authenticating..."
COOKIE_FILE="/tmp/fc-cookie-$$.txt"
if ! curl -sf -c "$COOKIE_FILE" -X POST \
    -H "Content-Type: application/json" \
    -d "{\"sharedSecretKey\":\"$PS_SHARED_SECRET\"}" \
    "http://${FC_GUEST_IP}:4001/api/auth" > /dev/null 2>&1; then
    die "Authentication failed"
fi

# Arrays to store results from all iterations
declare -a durations
declare -a throughputs
declare -a http_statuses

# Calculate file size once
size_mb=$(echo "$FILE_SIZE" | sed 's/M$//' | sed 's/G$/000/' | bc)

# Run upload test multiple times
for i in $(seq 1 $NUM_ITERATIONS); do
    log "Upload iteration $i/$NUM_ITERATIONS..."

    # Clear database before upload (except first iteration - fresh VM)
    if [[ $i -gt 1 ]]; then
        clear_response=$(curl -s -b "$COOKIE_FILE" -w "\n%{http_code}" -X POST \
            "http://${FC_GUEST_IP}:4001/api/debug/db/clear" 2>&1)
        clear_status=$(echo "$clear_response" | tail -1)
        clear_body=$(echo "$clear_response" | head -n -1)

        if [[ "$clear_status" != "200" ]]; then
            log "WARNING: Database clear failed for iteration $i (HTTP $clear_status)"
            [[ -n "$clear_body" ]] && log "  Error: $clear_body"
        fi
        sleep 0.5  # Brief pause after clear
    fi

    upload_start=$(date +%s.%N)

    # Save response to file to capture body
    response_file="/tmp/upload-response-$$-$i.txt"
    http_status=$(timeout "$TIMEOUT_SECONDS" curl -w "%{http_code}" -b "$COOKIE_FILE" -X POST \
        -F "file=@${TEST_FILE}" \
        -o "$response_file" \
        "http://${FC_GUEST_IP}:4001/api/entry?expiration=2040-01-01T00:00:00Z" 2>&1 | tail -1) || http_status="timeout"

    if [[ "$http_status" != "200" ]]; then
        log "  Upload failed with HTTP $http_status"
        if [[ -f "$response_file" ]]; then
            log "  Error response: $(cat "$response_file")"
        fi
    fi
    rm -f "$response_file"

    upload_end=$(date +%s.%N)
    duration=$(awk "BEGIN {printf \"%.2f\", $upload_end - $upload_start}")

    # Calculate throughput
    throughput=$(awk "BEGIN {printf \"%.2f\", $size_mb / $duration}")

    # Store results
    durations[$((i-1))]=$duration
    throughputs[$((i-1))]=$throughput
    http_statuses[$((i-1))]=$http_status

    log "  Iteration $i: ${duration}s, ${throughput} MB/s (HTTP $http_status)"
done

# Calculate statistics
calc_median() {
    local arr=("$@")
    local sorted=($(printf '%s\n' "${arr[@]}" | sort -n))
    local count=${#sorted[@]}
    local mid=$((count / 2))

    if [[ $((count % 2)) -eq 0 ]]; then
        # Even number of elements - average the two middle values
        echo $(awk "BEGIN {printf \"%.2f\", (${sorted[$((mid-1))]} + ${sorted[$mid]}) / 2}")
    else
        # Odd number of elements - return middle value
        echo "${sorted[$mid]}"
    fi
}

calc_avg() {
    local arr=("$@")
    local sum=0
    for val in "${arr[@]}"; do
        sum=$(awk "BEGIN {printf \"%.2f\", $sum + $val}")
    done
    echo $(awk "BEGIN {printf \"%.2f\", $sum / ${#arr[@]}}")
}

calc_stddev() {
    local arr=("$@")
    local avg=$1; shift
    arr=("$@")

    local sum_sq=0
    for val in "${arr[@]}"; do
        local diff=$(awk "BEGIN {printf \"%.2f\", $val - $avg}")
        sum_sq=$(awk "BEGIN {printf \"%.2f\", $sum_sq + ($diff * $diff)}")
    done

    echo $(awk "BEGIN {printf \"%.2f\", sqrt($sum_sq / ${#arr[@]})}")
}

median_duration=$(calc_median "${durations[@]}")
median_throughput=$(calc_median "${throughputs[@]}")
avg_duration=$(calc_avg "${durations[@]}")
avg_throughput=$(calc_avg "${throughputs[@]}")
stddev_duration=$(calc_stddev "$avg_duration" "${durations[@]}")
stddev_throughput=$(calc_stddev "$avg_throughput" "${throughputs[@]}")

# Count successful uploads
success_count=0
for status in "${http_statuses[@]}"; do
    [[ "$status" == "200" ]] && success_count=$((success_count + 1))
done

# Determine overall exit reason
exit_reason="success"
if [[ $success_count -eq 0 ]]; then
    exit_reason="all_failed"
elif [[ $success_count -lt $NUM_ITERATIONS ]]; then
    exit_reason="partial_success"
fi

# Generate result JSON with all measurements
cat > "$RESULT_FILE" << EOF
{
  "timestamp": "$(date -Iseconds)",
  "platform": "firecracker",
  "ram_mb": $RAM_MB,
  "file_size": "$FILE_SIZE",
  "file_size_mb": $size_mb,
  "boot_time_seconds": $boot_time,
  "num_iterations": $NUM_ITERATIONS,
  "iterations": [
EOF

for i in $(seq 0 $((NUM_ITERATIONS - 1))); do
    cat >> "$RESULT_FILE" << EOF
    {
      "iteration": $((i + 1)),
      "duration_seconds": ${durations[$i]},
      "throughput_mbps": ${throughputs[$i]},
      "http_status": "${http_statuses[$i]}"
    }$([[ $i -lt $((NUM_ITERATIONS - 1)) ]] && echo "," || echo "")
EOF
done

cat >> "$RESULT_FILE" << EOF
  ],
  "stats": {
    "median_duration_seconds": $median_duration,
    "median_throughput_mbps": $median_throughput,
    "avg_duration_seconds": $avg_duration,
    "avg_throughput_mbps": $avg_throughput,
    "stddev_duration_seconds": $stddev_duration,
    "stddev_throughput_mbps": $stddev_throughput,
    "success_count": $success_count,
    "failure_count": $((NUM_ITERATIONS - success_count))
  },
  "exit_reason": "$exit_reason",
  "success": $([ "$exit_reason" = "success" ] && echo "true" || echo "false")
}
EOF

# Display result
log ""
if [[ "$exit_reason" == "success" ]]; then
    log "✅ TEST PASSED (all $NUM_ITERATIONS iterations successful)"
elif [[ "$exit_reason" == "partial_success" ]]; then
    log "⚠️  TEST PARTIAL ($success_count/$NUM_ITERATIONS iterations successful)"
else
    log "❌ TEST FAILED (0/$NUM_ITERATIONS iterations successful)"
fi

log "   Boot Time: ${boot_time}s"
log "   Iterations: $NUM_ITERATIONS"
log "   Successful: $success_count"
log ""
log "   Median Throughput: ${median_throughput} MB/s"
log "   Avg Throughput: ${avg_throughput} ± ${stddev_throughput} MB/s"
log "   Median Duration: ${median_duration}s"
log "   Avg Duration: ${avg_duration} ± ${stddev_duration}s"
log ""
log "Results saved to: $RESULT_FILE"

echo "$RESULT_FILE"
exit $([ "$exit_reason" = "success" ] && echo 0 || echo 1)
